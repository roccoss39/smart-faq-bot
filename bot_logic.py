"""
Bot Logic - Logika konwersacji i zarzƒÖdzania sesjami u≈ºytkownik√≥w
Obs≈Çuguje rezerwacje, AI responses i stan konwersacji
"""

import logging
import re
from datetime import datetime, timedelta
import pytz
from together import Together
import os
from calendar_service import get_available_slots, create_appointment

logger = logging.getLogger(__name__)

# ==============================================
# KONFIGURACJA AI
# ==============================================

# Sprawd≈∫ czy klucz API jest dostƒôpny
api_key = os.getenv('TOGETHER_API_KEY')
if not api_key:
    logger.error("B≈ÅƒÑD: Brak zmiennej ≈õrodowiskowej TOGETHER_API_KEY")
    raise Exception("Brak Together API key")

client = Together(api_key=api_key)

# PROMPT SYSTEMOWY
SYSTEM_PROMPT = """
WA≈ªNE: Odpowiadaj BEZPO≈öREDNIO bez pokazywania swojego procesu my≈õlowego!
NIE u≈ºywaj tag√≥w <thinking> ani nie pokazuj swoich rozumowa≈Ñ!
Odpowiadaj tylko ko≈ÑcowƒÖ odpowiedziƒÖ!

Jeste≈õ AI asystentem salonu fryzjerskiego "Kleopatra" w Warszawie przy ul. Piƒôknej 15.

ZASADY ODPOWIEDZI:
- NIE pokazuj swojego procesu my≈õlowego
- NIE pisz "Okay, the user is asking..." 
- NIE u≈ºywaj tag√≥w <thinking></thinking>
- Odpowiadaj TYLKO po polsku
- BƒÖd≈∫ bezpo≈õredni i pomocny
- U≈ºywaj max 2-3 emoji na wiadomo≈õƒá
- Odpowiedzi max 300 znak√≥w (dla Facebook Messenger)

INFORMACJE O SALONIE:
- Nazwa: Salon Fryzjerski "Kleopatra"
- Adres: ul. Piƒôkna 15, 00-001 Warszawa
- Telefon: 123-456-789
- Email: kontakt@salon-kleopatra.pl
- Website: www.salon-kleopatra.pl

GODZINY OTWARCIA:
- Poniedzia≈Çek-PiƒÖtek: 9:00-19:00
- Sobota: 9:00-16:00  
- Niedziela: zamkniƒôte

CENNIK US≈ÅUG:
STRZY≈ªENIE:
- Damskie: 80-120 z≈Ç
- Mƒôskie: 50-70 z≈Ç
- Dzieciƒôce: 40 z≈Ç

KOLORYZACJA:
- Ca≈Ço≈õciowe farbowanie: 120-180 z≈Ç
- Retusz odrost√≥w: 80 z≈Ç
- Pasemka/refleksy: 150-250 z≈Ç

Odpowiadaj TYLKO po polsku. BƒÖd≈∫ pomocny i empatyczny.
Pamiƒôtaj: NIE pokazuj procesu my≈õlowego!
"""

# ==============================================
# SYSTEM SESJI U≈ªYTKOWNIK√ìW
# ==============================================

user_sessions = {}

class UserSession:
    def __init__(self, user_id):
        self.user_id = user_id
        self.state = "start"  # start, booking, waiting_for_details, ready_to_book
        self.appointment_data = {}
        self.last_activity = datetime.now()
        
    def set_booking_details(self, day, time, service):
        """Ustaw szczeg√≥≈Çy rezerwacji"""
        self.appointment_data = {
            'day': day,
            'time': time, 
            'service': service
        }
        self.state = "waiting_for_details"
        self.last_activity = datetime.now()
        
    def set_client_details(self, name, phone):
        """Ustaw dane klienta"""
        self.appointment_data['name'] = name
        self.appointment_data['phone'] = phone
        self.state = "ready_to_book"
        self.last_activity = datetime.now()
        
    def reset(self):
        """Resetuj sesjƒô"""
        self.state = "start"
        self.appointment_data = {}
        self.last_activity = datetime.now()
        
    def is_expired(self, minutes=30):
        """Sprawd≈∫ czy sesja wygas≈Ça"""
        return (datetime.now() - self.last_activity).total_seconds() > (minutes * 60)

def get_user_session(user_id):
    """Pobierz lub utw√≥rz sesjƒô u≈ºytkownika"""
    if user_id not in user_sessions:
        user_sessions[user_id] = UserSession(user_id)
    
    session = user_sessions[user_id]
    
    # Sprawd≈∫ czy sesja nie wygas≈Ça
    if session.is_expired():
        logger.info(f"üïê Sesja {user_id} wygas≈Ça - resetowanie")
        session.reset()
    
    return session

def cleanup_expired_sessions():
    """Usu≈Ñ wygas≈Çe sesje (wywo≈Çuj okresowo)"""
    expired_users = [
        user_id for user_id, session in user_sessions.items() 
        if session.is_expired()
    ]
    
    for user_id in expired_users:
        del user_sessions[user_id]
        logger.info(f"üóëÔ∏è Usuniƒôto wygas≈ÇƒÖ sesjƒô: {user_id}")

# ==============================================
# PARSOWANIE WIADOMO≈öCI
# ==============================================

def parse_booking_message(message):
    """WyciƒÖgnij szczeg√≥≈Çy rezerwacji z wiadomo≈õci"""
    try:
        message_lower = message.lower().strip()
        logger.info(f"üîç PARSING: '{message}' ‚Üí '{message_lower}'")  # DEBUG
        
        # Znajd≈∫ dzie≈Ñ
        days_map = {
            'poniedzia≈Çek': 'Poniedzia≈Çek', 'poniedzialek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
            'wtorek': 'Wtorek', 'wt': 'Wtorek',
            '≈õroda': '≈öroda', 'sroda': '≈öroda', '≈õr': '≈öroda', 'sr': '≈öroda',
            'czwartek': 'Czwartek', 'czw': 'Czwartek',
            'piƒÖtek': 'PiƒÖtek', 'piatek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
            'sobota': 'Sobota', 'sobote': 'Sobota', 'sb': 'Sobota'
        }
        
        day = None
        for day_key, day_value in days_map.items():
            if day_key in message_lower:
                day = day_value
                break
                
        # Znajd≈∫ godzinƒô (r√≥≈ºne formaty)
        time_patterns = [
            r'(\d{1,2}):(\d{2})',                    # 10:00
            r'(\d{1,2})\.(\d{2})',                   # 10.00
            r'(\d{1,2}):(\d{0,2})',                  # 10: lub 10:0
            r'(\d{1,2})\s*h',                        # 10h
            r'godz\.?\s*(\d{1,2})',                  # godz 10
            r'o\s+(\d{1,2}):?(\d{0,2})',             # "o 10:00" lub "o 10"
            r'na\s+(\d{1,2}):?(\d{0,2})',            # "na 10:00"  ‚Üê DODAJ
            r'(\d{1,2}):?(\d{0,2})\s+na',            # "10:00 na"  ‚Üê DODAJ
        ]
        
        time = None
        for pattern in time_patterns:
            time_match = re.search(pattern, message_lower)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if len(time_match.groups()) > 1 and time_match.group(2) else 0
                
                # Walidacja godziny
                if 9 <= hour <= 19:  # Godziny pracy
                    time = f"{hour:02d}:{minute:02d}"
                    break
                    
        # Znajd≈∫ us≈Çugƒô
        services_map = {
            'strzy≈ºenie mƒôskie': 'Strzy≈ºenie mƒôskie',
            'strzy≈ºenie damskie': 'Strzy≈ºenie damskie',
            'strzy≈ºenie': 'Strzy≈ºenie',
            'strzyenie': 'Strzy≈ºenie',  # liter√≥wka
            'farbowanie': 'Farbowanie',
            'farba': 'Farbowanie',
            'pasemka': 'Pasemka',
            'refleksy': 'Refleksy',
            'koloryzacja': 'Koloryzacja',
            'ombre': 'Ombre',
            'baleyage': 'Baleyage'
        }
        
        service = 'Strzy≈ºenie'  # domy≈õlnie
        for service_key, service_value in services_map.items():
            if service_key in message_lower:
                service = service_value
                break
                
        if day and time:
            return {
                'day': day,
                'time': time,
                'service': service
            }
            
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania rezerwacji: {e}")
        return None

def parse_contact_data(message):
    """WyciƒÖgnij dane kontaktowe z wiadomo≈õci"""
    try:
        message = message.strip()
        
        # R√≥≈ºne wzorce dla danych kontaktowych
        patterns = [
            # "Jan Kowalski, 123456789"
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
            # "Jan Kowalski 123456789"  
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
            # "Jan Kowalski tel: 123456789"
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s*tel\.?\s*:?\s*(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message)
            if match:
                name = f"{match.group(1)} {match.group(2)}"
                phone = re.sub(r'[-\s]', '', match.group(3))
                
                # Walidacja telefonu (9 cyfr)
                if len(phone) == 9 and phone.isdigit():
                    return {
                        'name': name,
                        'phone': phone
                    }
            
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania kontaktu: {e}")
        return None

# ==============================================
# TWORZENIE WIZYT
# ==============================================

def create_booking(appointment_data):
    """Utw√≥rz wizytƒô w kalendarzu Google"""
    try:
        # Konwertuj dane na datetime
        day_map = {
            'Poniedzia≈Çek': 0, 'Wtorek': 1, '≈öroda': 2, 
            'Czwartek': 3, 'PiƒÖtek': 4, 'Sobota': 5
        }
        
        target_day = day_map.get(appointment_data['day'])
        if target_day is None:
            logger.error(f"‚ùå Nieprawid≈Çowy dzie≈Ñ: {appointment_data['day']}")
            return False
            
        # Znajd≈∫ najbli≈ºszy dzie≈Ñ
        tz = pytz.timezone('Europe/Warsaw')
        now = datetime.now(tz)
        days_ahead = (target_day - now.weekday()) % 7
        if days_ahead == 0:  # Dzisiaj
            days_ahead = 7  # Nastƒôpny tydzie≈Ñ
            
        appointment_date = now + timedelta(days=days_ahead)
        
        # Ustaw godzinƒô
        time_parts = appointment_data['time'].split(':')
        appointment_datetime = appointment_date.replace(
            hour=int(time_parts[0]), 
            minute=int(time_parts[1]), 
            second=0, 
            microsecond=0
        )
        
        # Sprawd≈∫ czy termin nie jest w przesz≈Ço≈õci
        if appointment_datetime <= now:
            logger.error(f"‚ùå Termin w przesz≈Ço≈õci: {appointment_datetime}")
            return False
        
        logger.info(f"üìÖ Tworzenie wizyty: {appointment_datetime} dla {appointment_data['name']}")
        
        # Utw√≥rz wizytƒô w kalendarzu
        result = create_appointment(
            client_name=appointment_data['name'],
            client_phone=appointment_data['phone'],
            service_type=appointment_data['service'],
            appointment_time=appointment_datetime
        )
        
        if result:
            logger.info(f"‚úÖ Wizyta utworzona! ID: {result}")
            return True
        else:
            logger.error("‚ùå B≈ÇƒÖd tworzenia wizyty w kalendarzu")
            return False
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd tworzenia wizyty: {e}")
        return False

# ==============================================
# CZYSZCZENIE ODPOWIEDZI AI
# ==============================================

# ZASTƒÑP funkcjƒô clean_thinking_response:

def clean_thinking_response(response_text):
    """Usuwa sekcje 'thinking' z odpowiedzi modelu DeepSeek-R1"""
    if not response_text:
        return ""
        
    original = response_text
    cleaned = response_text
    
    # SZCZEG√ìLNE TRAKTOWANIE NIEDOMKNIƒòTEGO <think>
    # Znajd≈∫ wszystko po ostatnim </think> lub <think> 
    
    # Je≈õli jest <think> ale nie ma </think>, we≈∫ tylko tekst po <think>
    if '<think>' in cleaned.lower() and '</think>' not in cleaned.lower():
        # Znajd≈∫ indeks ostatniego <think>
        think_pattern = re.compile(r'<think[^>]*>', re.IGNORECASE)
        matches = list(think_pattern.finditer(cleaned))
        if matches:
            # We≈∫ tekst po ostatnim <think>
            last_match = matches[-1]
            after_think = cleaned[last_match.end():]
            
            # Sprawd≈∫ czy po <think> jest sensowna odpowied≈∫
            lines = after_think.strip().split('\n')
            for line in lines:
                line = line.strip()
                # Szukaj linii z jednƒÖ z poprawnych intencji
                if any(intent in line.upper() for intent in ["BOOKING", "SHOW_AVAILABLE", "GENERAL_BOOKING", "CONTACT_INFO", "CANCEL", "GENERAL"]):
                    cleaned = line
                    break
            else:
                # Je≈õli nie znaleziono intencji, we≈∫ pierwszƒÖ sensownƒÖ liniƒô
                for line in lines:
                    if len(line.strip()) > 0 and not line.strip().startswith('<'):
                        cleaned = line.strip()
                        break
    
    # Usu≈Ñ wszystko miƒôdzy zamkniƒôtymi tagami
    cleaned = re.sub(r'<thinking>.*?</thinking>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    cleaned = re.sub(r'<THINK>.*?</THINK>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    cleaned = re.sub(r'<think>.*?</think>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    
    # Usu≈Ñ ewentualne pozosta≈Çe tagi
    cleaned = re.sub(r'<[^>]*>', '', cleaned)
    
    # Usu≈Ñ ewentualne puste linie
    cleaned = cleaned.strip()
    
    # Debug log
    if original != cleaned and len(original) > 50:
        logger.debug(f"üßπ Oczyszczono: '{original[:50]}...' ‚Üí '{cleaned}'")
    
    return cleaned

# ==============================================
# G≈Å√ìWNA LOGIKA BOTA
# ==============================================

def process_user_message(user_message, user_id=None):
    """
    G≈Å√ìWNA FUNKCJA - Przetw√≥rz wiadomo≈õƒá u≈ºytkownika z AI Intent Router
    """
    try:
        # Pobierz sesjƒô u≈ºytkownika
        session = get_user_session(user_id) if user_id else None
        user_message = user_message.strip()
        
        logger.info(f"ü§ñ Przetwarzam: '{user_message}' | Sesja: {session.state if session else 'brak'}")
        
        # ===========================================
        # AI ANALYSIS INTENCJI
        # ===========================================
        
        intent = analyze_user_intent(user_message, session)
        
        # ===========================================
        # OBS≈ÅUGA NA PODSTAWIE INTENCJI
        # ===========================================
        
        # 1. CONTACT_DATA - gdy klient podaje dane kontaktowe
        if intent == "CONTACT_DATA" and session and session.state == "waiting_for_details":
            contact_data = parse_contact_data(user_message)
            if contact_data:
                session.set_client_details(contact_data['name'], contact_data['phone'])
                
                # UTW√ìRZ WIZYTƒò W KALENDARZU
                appointment_result = create_booking(session.appointment_data)
                
                if appointment_result:
                    confirmation = f"‚úÖ **WIZYTA POTWIERDZONA!**\n\nüìÖ **Termin:** {session.appointment_data['day']} {session.appointment_data['time']}\nüë§ **Klient:** {contact_data['name']}\nüìû **Telefon:** {contact_data['phone']}\n‚úÇÔ∏è **Us≈Çuga:** {session.appointment_data['service']}\n\nüìç **Salon Kleopatra**\nul. Piƒôkna 15, Warszawa\n\nüéâ Do zobaczenia w salonie!"
                    session.reset()
                    return confirmation
                else:
                    session.reset()
                    return f"‚ùå **B≈ÇƒÖd rezerwacji**\n\nTermin m√≥g≈Ç zostaƒá zajƒôty przez kogo≈õ innego.\nüìû Zadzwo≈Ñ: **123-456-789**"
            else:
                return f"üìù **B≈Çƒôdny format!**\n\nNapisz w formacie:\n**\"Imiƒô Nazwisko, numer telefonu\"**\n\nNp: **\"Jan Kowalski, 123456789\"**"
        
        # 1.5. CANCELLING - weryfikacja danych do anulowania
        if session and session.state == "cancelling":
            cancellation_data = parse_cancellation_data(user_message)
            if cancellation_data:
                # TODO: Sprawd≈∫ w kalendarzu czy wizyta istnieje
                session.reset()
                return f"‚úÖ **Wizyta anulowana**\n\nüë§ Klient: {cancellation_data['name']}\nüìû Telefon: {cancellation_data['phone']}\nüìÖ Termin: {cancellation_data['day']} {cancellation_data['time']}\n\nü§ñ Czy mogƒô w czym≈õ jeszcze pom√≥c?"
            else:
                return f"üìù **B≈Çƒôdny format!**\n\nPodaj w formacie:\n**\"Imiƒô Nazwisko, telefon, dzie≈Ñ godzina\"**\n\nNp: *\"Jan Kowalski, 123456789, ≈õroda 11:00\"*"
        
        # 2. BOOKING - konkretna rezerwacja "umawiam siƒô na wtorek 10:00"
        elif intent == "BOOKING":
            parsed = parse_booking_message(user_message)
            logger.info(f"üîç PARSED BOOKING: {parsed}")
            
            if parsed and session:
                session.set_booking_details(parsed['day'], parsed['time'], parsed['service'])
                return f"üìù **Prawie gotowe!**\n\nüìÖ **Termin:** {parsed['day']} {parsed['time']}\n‚úÇÔ∏è **Us≈Çuga:** {parsed['service']}\n\nüîî Potrzebujƒô jeszcze:\n‚Ä¢ üë§ **Imiƒô i nazwisko**\n‚Ä¢ üìû **Numer telefonu**\n\nNapisz: **\"Jan Kowalski, 123456789\"**"
            else:
                return f"üìù **Nie mogƒô rozpoznaƒá terminu!**\n\nSprawd≈∫ format:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"**\n\nNp: *\"Umawiam siƒô na wtorek 10:00 na strzy≈ºenie\"*"
        
        # 3. ASK_AVAILABILITY - pytanie o dostƒôpne terminy
        elif intent == "ASK_AVAILABILITY":
            day_mentioned = extract_day_from_message(user_message)
            
            try:
                slots = get_available_slots(days_ahead=10)
                
                if day_mentioned:
                    day_slots = [slot for slot in slots if slot['day_name'] == day_mentioned]
                    if day_slots:
                        slots_text = '\n'.join([
                            f"‚Ä¢ {slot['display'].split()[-1]}"
                            for slot in day_slots[:10]
                        ])
                        day_display = get_day_in_locative(day_mentioned)  # ‚Üê NOWA FUNKCJA
                        return f"üìÖ **Wolne terminy {day_display}:**\n{slots_text}\n\nüí¨ Aby siƒô um√≥wiƒá napisz:\n**\"Umawiam siƒô na {day_mentioned.lower()} [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                    else:
                        other_days = [slot for slot in slots if slot['day_name'] != day_mentioned][:5]
                        if other_days:
                            slots_text = '\n'.join([
                                f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                                for slot in other_days
                            ])
                            return f"üòî Brak wolnych termin√≥w w {day_mentioned.lower()}.\n\nüìÖ **Dostƒôpne w inne dni:**\n{slots_text}\n\nüìû Lub zadzwo≈Ñ: **123-456-789**"
                        else:
                            return f"üòî Brak wolnych termin√≥w w {day_mentioned.lower()}.\nüìû Zadzwo≈Ñ: **123-456-789**"
                else:
                    if slots:
                        slots_text = '\n'.join([
                            f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                            for slot in slots[:8]
                        ])
                        return f"üìÖ **Dostƒôpne terminy:**\n{slots_text}\n\nüí¨ Napisz:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                    else:
                        return "üòî Brak wolnych termin√≥w w najbli≈ºszych dniach.\nüìû Zadzwo≈Ñ: **123-456-789**"
                        
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania termin√≥w: {e}")
                return "üòî Problem z kalendar≈ºem. Zadzwo≈Ñ: **123-456-789** üìû"
        
        # 4. WANT_APPOINTMENT - og√≥lne "chcƒô siƒô um√≥wiƒá"
        elif intent == "WANT_APPOINTMENT":
            try:
                slots = get_available_slots(days_ahead=10)
                if slots:
                    if session:
                        session.state = "booking"
                    
                    slots_text = '\n'.join([
                        f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                        for slot in slots[:8]
                    ])
                    
                    return f"üìÖ **Dostƒôpne terminy:**\n{slots_text}\n\nüí¨ Napisz:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                else:
                    return "üòî Brak wolnych termin√≥w w najbli≈ºszych dniach.\nüìû Zadzwo≈Ñ: **123-456-789**"
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania termin√≥w: {e}")
                return "üòî Problem z kalendar≈ºem. Zadzwo≈Ñ: **123-456-789** üìû"
        
        # 5. CANCEL_VISIT - anulowanie z weryfikacjƒÖ
        elif intent == "CANCEL_VISIT":
            if session and session.state == "waiting_for_details" and session.appointment_data:
                # User ma aktywnƒÖ rezerwacjƒô - anuluj jƒÖ
                appointment_info = session.appointment_data
                session.reset()
                return f"‚ùå **Anulowano rezerwacjƒô**\n\nüìÖ Termin: {appointment_info['day']} {appointment_info['time']}\n‚úÇÔ∏è Us≈Çuga: {appointment_info['service']}\n\nü§ñ Mogƒô Ci w czym≈õ jeszcze pom√≥c?"
            else:
                # Pytaj o szczeg√≥≈Çy wizyty do anulowania
                if session:
                    session.state = "cancelling"
                return f"‚ùå **Anulowanie wizyty**\n\nüîç Aby anulowaƒá wizytƒô, podaj:\n‚Ä¢ üë§ **Imiƒô i nazwisko**\n‚Ä¢ üìû **Numer telefonu**\n‚Ä¢ üìÖ **Dzie≈Ñ i godzinƒô wizyty**\n\nNp: *\"Jan Kowalski, 123456789, ≈õroda 11:00\"*"
        
        # 6. OTHER_QUESTION - standardowa rozmowa AI
        else:  # OTHER_QUESTION
            return get_ai_response(user_message)
            
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd przetwarzania wiadomo≈õci: {e}")
        return "üòî WystƒÖpi≈Ç problem. Spr√≥buj ponownie lub zadzwo≈Ñ: **123-456-789** üìû"

# ===========================================
# DODAJ POMOCNICZE FUNKCJE
# ===========================================

def extract_day_from_message(message):
    """WyciƒÖgnij dzie≈Ñ z wiadomo≈õci"""
    days_map = {
        'poniedzia≈Çek': 'Poniedzia≈Çek', 'poniedzialek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
        'wtorek': 'Wtorek', 'wt': 'Wtorek',
        '≈õroda': '≈öroda', 'sroda': '≈öroda', '≈õr': '≈öroda',
        'czwartek': 'Czwartek', 'czw': 'Czwartek',
        'piƒÖtek': 'PiƒÖtek', 'piatek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
        'sobota': 'Sobota', 'sobote': 'Sobota', 'sb': 'Sobota'
    }
    
    message_lower = message.lower()
    for day_key, day_value in days_map.items():
        if day_key in message_lower:
            return day_value
    return None

def get_ai_response(user_message):
    """Standardowa odpowied≈∫ AI"""
    try:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_message}
        ]
        
        response = client.chat.completions.create(
            model="deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free",  # ‚Üê POWR√ìT DO R1
            messages=messages,
            max_tokens=600,
            temperature=0.3
        )
        
        raw_response = response.choices[0].message.content
        cleaned_response = clean_thinking_response(raw_response)
        
        # Sprawd≈∫ czy jest czysta odpowied≈∫
        if len(cleaned_response.strip()) > 10:
            return cleaned_response.strip()
        else:
            return "üòä Dzie≈Ñ dobry! Jak mogƒô pom√≥c? Zapraszamy do salonu Kleopatra na ul. Piƒôknej 15! üíá‚Äç‚ôÄÔ∏è"
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd AI response: {e}")
        return "üòî Przepraszam, chwilowo mam problemy z odpowiadaniem. Zadzwo≈Ñ: **123-456-789** üìû"

# ZASTƒÑP funkcjƒô analyze_user_intent:

def analyze_user_intent(user_message):
    """Analizuj intencjƒô u≈ºytkownika za pomocƒÖ AI"""
    intent_prompt = f"""Classify this Polish message into ONE category.

MESSAGE: "{user_message}"

CATEGORIES:

**BOOKING** - Specific booking with BOTH day AND time mentioned
Examples: "umawiam siƒô na wtorek 10:00", "≈õroda 15:30", "poniedzia≈Çek o 11:00"

**ASK_AVAILABILITY** - Asking about available appointment times
Examples: "kiedy majƒÖ pa≈Ñstwo wolne terminy?", "dostƒôpne godziny na wtorek?", "jakie sƒÖ wolne terminy?"

**WANT_APPOINTMENT** - General booking request WITHOUT specific time
Examples: "chce sie ostrzyc", "chcƒô siƒô um√≥wiƒá", "potrzebujƒô wizyty"

**CONTACT_DATA** - Personal contact details
Examples: "Jan Kowalski, 123456789", "Anna Nowak 987-654-321"

**CANCEL_VISIT** - Cancel appointment request
Examples: "anuluj", "rezygnujƒô", "odwo≈Çujƒô wizytƒô"

**OTHER_QUESTION** - Other questions about salon, greetings
Examples: "cze≈õƒá", "ile kosztuje strzy≈ºenie?", "gdzie jeste≈õcie?"

IMPORTANT RULES:
- If message has day AND time ‚Üí BOOKING
- If only general appointment request ‚Üí WANT_APPOINTMENT  
- If asking about availability ‚Üí ASK_AVAILABILITY

ANSWER: Write ONLY the category name (e.g. BOOKING, WANT_APPOINTMENT, etc.)"""

    try:
        response = client.chat.completions.create(
            model="deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free",
            messages=[{"role": "user", "content": intent_prompt}],
            max_tokens=1000,
            temperature=0.0
        )
        
        raw_intent = response.choices[0].message.content
        
        # DEBUG: Poka≈º pe≈ÇnƒÖ odpowied≈∫
        print(f"üîç FULL RAW RESPONSE:")
        print(f"'{raw_intent}'")
        print(f"üîç LENGTH: {len(raw_intent)}")
        
        # NOWE NAZWY KATEGORII
        valid_intents = ["BOOKING", "ASK_AVAILABILITY", "WANT_APPOINTMENT", "CONTACT_DATA", "CANCEL_VISIT", "OTHER_QUESTION"]
        
        # SZUKAJ OSTATNIEJ LINII Z INTENCJƒÑ
        lines = raw_intent.split('\n')
        found_intent = None
        
        for line in reversed(lines):
            line_clean = line.strip().upper()
            if line_clean in valid_intents:
                found_intent = line_clean
                print(f"üéØ FOUND INTENT IN LINE: '{line_clean}'")
                break
        
        # Je≈õli nie znaleziono w osobnej linii, szukaj jako ostatnie s≈Çowo
        if not found_intent:
            for intent in valid_intents:
                if raw_intent.upper().strip().endswith(intent):
                    found_intent = intent
                    print(f"üéØ FOUND INTENT AT END: '{intent}'")
                    break
        
        # Je≈õli nadal nie znaleziono, szukaj w ca≈Çym tek≈õcie
        if not found_intent:
            for intent in valid_intents:
                if intent in raw_intent.upper():
                    found_intent = intent
                    print(f"üéØ FOUND INTENT ANYWHERE: '{intent}'")
                    break
        
        if found_intent:
            logger.info(f"üéØ Intent rozpoznany: '{user_message}' ‚Üí {found_intent}")
            return found_intent
        
        # Fallback
        logger.warning(f"ü§î Nierozpoznana intencja dla '{user_message}' ‚Üí OTHER_QUESTION")
        print(f"‚ùå NO INTENT FOUND, DEFAULTING TO OTHER_QUESTION")
        return "OTHER_QUESTION"
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd analizy intencji: {e}")
        return "OTHER_QUESTION"

# ==============================================
# FUNKCJE POMOCNICZE
# ==============================================

def get_session_info(user_id):
    """Pobierz informacje o sesji u≈ºytkownika (dla debugowania)"""
    if user_id in user_sessions:
        session = user_sessions[user_id]
        return {
            'state': session.state,
            'appointment_data': session.appointment_data,
            'last_activity': session.last_activity.isoformat()
        }
    return None

def reset_user_session(user_id):
    """Resetuj sesjƒô u≈ºytkownika"""
    if user_id in user_sessions:
        user_sessions[user_id].reset()
        return True
    return False

def get_active_sessions_count():
    """Zwr√≥ƒá liczbƒô aktywnych sesji"""
    return len(user_sessions)

# ==============================================
# INICJALIZACJA
# ==============================================

logger.info("ü§ñ Bot Logic zainicjalizowany")
logger.info(f"üîë Together API: {'‚úÖ' if api_key else '‚ùå'}")

def get_day_in_locative(day_name):
    """Zwr√≥ƒá dzie≈Ñ w miejscowniku (w + dzie≈Ñ)"""
    locative_map = {
        'Poniedzia≈Çek': 'w poniedzia≈Çek',
        'Wtorek': 'we wtorek', 
        '≈öroda': 'w ≈õrodƒô',
        'Czwartek': 'w czwartek',
        'PiƒÖtek': 'w piƒÖtek',
        'Sobota': 'w sobotƒô'
    }
    return locative_map.get(day_name, f'w {day_name.lower()}')

def get_day_in_accusative(day_name):
    """Zwr√≥ƒá dzie≈Ñ w bierniku (na + dzie≈Ñ)"""
    accusative_map = {
        'Poniedzia≈Çek': 'poniedzia≈Çek',
        'Wtorek': 'wtorek',
        '≈öroda': '≈õrodƒô', 
        'Czwartek': 'czwartek',
        'PiƒÖtek': 'piƒÖtek',
        'Sobota': 'sobotƒô'
    }
    return accusative_map.get(day_name, day_name.lower())

# DODAJ NOWƒÑ FUNKCJƒò parse_cancellation_data:

def parse_cancellation_data(message):
    """WyciƒÖgnij dane do anulowania wizyty"""
    try:
        # Wzorce dla: "Jan Kowalski, 123456789, ≈õroda 11:00"
        patterns = [
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})[,\s]+([a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{1,2}):?(\d{0,2})',
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9})[,\s]+([a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{1,2}):?(\d{0,2})'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message)
            if match:
                name = f"{match.group(1)} {match.group(2)}"
                phone = re.sub(r'[-\s]', '', match.group(3))
                day_raw = match.group(4).lower()
                hour = int(match.group(5))
                minute = int(match.group(6)) if match.group(6) else 0
                
                # Mapuj dzie≈Ñ
                days_map = {
                    'poniedzia≈Çek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
                    'wtorek': 'Wtorek', 'wt': 'Wtorek',
                    '≈õroda': '≈öroda', '≈õrodƒô': '≈öroda', 'sr': '≈öroda',
                    'czwartek': 'Czwartek', 'czw': 'Czwartek',
                    'piƒÖtek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
                    'sobota': 'Sobota', 'sobotƒô': 'Sobota', 'sb': 'Sobota'
                }
                
                day = days_map.get(day_raw)
                time = f"{hour:02d}:{minute:02d}"
                
                if day and len(phone) == 9:
                    return {
                        'name': name,
                        'phone': phone,
                        'day': day,
                        'time': time
                    }
        
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania anulowania: {e}")
        return None