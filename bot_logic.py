"""
Bot Logic - Logika konwersacji i zarzƒÖdzania sesjami u≈ºytkownik√≥w
Obs≈Çuguje rezerwacje, AI responses i stan konwersacji
"""

import logging
import re
from datetime import datetime, timedelta
import pytz
from together import Together
import os
from calendar_service import get_available_slots, create_appointment, cancel_appointment

logger = logging.getLogger(__name__)

# ==============================================
# KONFIGURACJA AI
# ==============================================

# Sprawd≈∫ czy klucz API jest dostƒôpny
api_key = os.getenv('TOGETHER_API_KEY')
if not api_key:
    logger.error("B≈ÅƒÑD: Brak zmiennej ≈õrodowiskowej TOGETHER_API_KEY")
    raise Exception("Brak Together API key")

client = Together(api_key=api_key)

# PROMPT SYSTEMOWY
SYSTEM_PROMPT = """
WA≈ªNE: Odpowiadaj BEZPO≈öREDNIO bez pokazywania swojego procesu my≈õlowego!
NIE u≈ºywaj tag√≥w <thinking> ani nie pokazuj swoich rozumowa≈Ñ!
Odpowiadaj tylko ko≈ÑcowƒÖ odpowiedziƒÖ!

Jeste≈õ AI asystentem salonu fryzjerskiego "Kleopatra" w Warszawie przy ul. Piƒôknej 15.

ZASADY ODPOWIEDZI:
- NIE pokazuj swojego procesu my≈õlowego
- NIE pisz "Okay, the user is asking..." 
- NIE u≈ºywaj tag√≥w <thinking></thinking>
- Odpowiadaj TYLKO po polsku
- BƒÖd≈∫ bezpo≈õredni i pomocny
- U≈ºywaj max 2-3 emoji na wiadomo≈õƒá
- Odpowiedzi max 300 znak√≥w (dla Facebook Messenger)

INFORMACJE O SALONIE:
- Nazwa: Salon Fryzjerski "Kleopatra"
- Adres: ul. Piƒôkna 15, 00-001 Warszawa
- Telefon: 123-456-789
- Email: kontakt@salon-kleopatra.pl
- Website: www.salon-kleopatra.pl

GODZINY OTWARCIA:
- Poniedzia≈Çek-PiƒÖtek: 9:00-19:00
- Sobota: 9:00-16:00  
- Niedziela: zamkniƒôte

CENNIK US≈ÅUG:
STRZY≈ªENIE:
- Damskie: 80-120 z≈Ç
- Mƒôskie: 50-70 z≈Ç
- Dzieciƒôce: 40 z≈Ç

KOLORYZACJA:
- Ca≈Ço≈õciowe farbowanie: 120-180 z≈Ç
- Retusz odrost√≥w: 80 z≈Ç
- Pasemka/refleksy: 150-250 z≈Ç

Odpowiadaj TYLKO po polsku. BƒÖd≈∫ pomocny i empatyczny.
Pamiƒôtaj: NIE pokazuj procesu my≈õlowego!
"""

# ==============================================
# SYSTEM SESJI U≈ªYTKOWNIK√ìW
# ==============================================

user_sessions = {}

class UserSession:
    def __init__(self, user_id):
        self.user_id = user_id
        self.state = "start"  # start, booking, waiting_for_details, ready_to_book
        self.appointment_data = {}
        self.last_activity = datetime.now()
        
    def set_booking_details(self, day, time, service):
        """Ustaw szczeg√≥≈Çy rezerwacji"""
        self.appointment_data = {
            'day': day,
            'time': time, 
            'service': service
        }
        self.state = "waiting_for_details"
        self.last_activity = datetime.now()
        
    def set_client_details(self, name, phone):
        """Ustaw dane klienta"""
        self.appointment_data['name'] = name
        self.appointment_data['phone'] = phone
        self.state = "ready_to_book"
        self.last_activity = datetime.now()
        
    def reset(self):
        """Resetuj sesjƒô"""
        self.state = "start"
        self.appointment_data = {}
        self.last_activity = datetime.now()
        
    def is_expired(self, minutes=30):
        """Sprawd≈∫ czy sesja wygas≈Ça"""
        return (datetime.now() - self.last_activity).total_seconds() > (minutes * 60)

def get_user_session(user_id):
    """Pobierz lub utw√≥rz sesjƒô u≈ºytkownika"""
    if user_id not in user_sessions:
        user_sessions[user_id] = UserSession(user_id)
    
    session = user_sessions[user_id]
    
    # Sprawd≈∫ czy sesja nie wygas≈Ça
    if session.is_expired():
        logger.info(f"üïê Sesja {user_id} wygas≈Ça - resetowanie")
        session.reset()
    
    return session

def cleanup_expired_sessions():
    """Usu≈Ñ wygas≈Çe sesje (wywo≈Çuj okresowo)"""
    expired_users = [
        user_id for user_id, session in user_sessions.items() 
        if session.is_expired()
    ]
    
    for user_id in expired_users:
        del user_sessions[user_id]
        logger.info(f"üóëÔ∏è Usuniƒôto wygas≈ÇƒÖ sesjƒô: {user_id}")

# ==============================================
# PARSOWANIE WIADOMO≈öCI
# ==============================================

def parse_booking_message(message):
    """WyciƒÖgnij szczeg√≥≈Çy rezerwacji z wiadomo≈õci"""
    try:
        message_lower = message.lower().strip()
        logger.info(f"üîç PARSING: '{message}' ‚Üí '{message_lower}'")  # DEBUG
        
        # Znajd≈∫ dzie≈Ñ
        days_map = {
            'poniedzia≈Çek': 'Poniedzia≈Çek', 'poniedzialek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
            'wtorek': 'Wtorek', 'wt': 'Wtorek',
            '≈õroda': '≈öroda', 'sroda': '≈öroda', '≈õr': '≈öroda', 'sr': '≈öroda',
            'czwartek': 'Czwartek', 'czw': 'Czwartek',
            'piƒÖtek': 'PiƒÖtek', 'piatek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
            'sobota': 'Sobota', 'sobote': 'Sobota', 'sb': 'Sobota'
        }
        
        day = None
        for day_key, day_value in days_map.items():
            if day_key in message_lower:
                day = day_value
                break
                
        # Znajd≈∫ godzinƒô (r√≥≈ºne formaty)
        time_patterns = [
            r'(\d{1,2}):(\d{2})',                    # 10:00
            r'(\d{1,2})\.(\d{2})',                   # 10.00
            r'(\d{1,2}):(\d{0,2})',                  # 10: lub 10:0
            r'(\d{1,2})\s*h',                        # 10h
            r'godz\.?\s*(\d{1,2})',                  # godz 10
            r'o\s+(\d{1,2}):?(\d{0,2})',             # "o 10:00" lub "o 10"
            r'na\s+(\d{1,2}):?(\d{0,2})',            # "na 10:00"  ‚Üê DODAJ
            r'(\d{1,2}):?(\d{0,2})\s+na',            # "10:00 na"  ‚Üê DODAJ
        ]
        
        time = None
        for pattern in time_patterns:
            time_match = re.search(pattern, message_lower)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if len(time_match.groups()) > 1 and time_match.group(2) else 0
                
                # Walidacja godziny
                if 9 <= hour <= 19:  # Godziny pracy
                    time = f"{hour:02d}:{minute:02d}"
                    break
                    
        # Znajd≈∫ us≈Çugƒô
        services_map = {
            'strzy≈ºenie mƒôskie': 'Strzy≈ºenie mƒôskie',
            'strzy≈ºenie damskie': 'Strzy≈ºenie damskie',
            'strzy≈ºenie': 'Strzy≈ºenie',
            'strzyenie': 'Strzy≈ºenie',  # liter√≥wka
            'farbowanie': 'Farbowanie',
            'farba': 'Farbowanie',
            'pasemka': 'Pasemka',
            'refleksy': 'Refleksy',
            'koloryzacja': 'Koloryzacja',
            'ombre': 'Ombre',
            'baleyage': 'Baleyage'
        }
        
        service = 'Strzy≈ºenie'  # domy≈õlnie
        for service_key, service_value in services_map.items():
            if service_key in message_lower:
                service = service_value
                break
                
        if day and time:
            return {
                'day': day,
                'time': time,
                'service': service
            }
            
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania rezerwacji: {e}")
        return None

def parse_contact_data(message):
    """WyciƒÖgnij dane kontaktowe z wiadomo≈õci"""
    try:
        message = message.strip()
        
        # R√≥≈ºne wzorce dla danych kontaktowych
        patterns = [
            # "Jan Kowalski, 123456789"
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
            # "Jan Kowalski 123456789"  
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
            # "Jan Kowalski tel: 123456789"
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s*tel\.?\s*:?\s*(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message)
            if match:
                name = f"{match.group(1)} {match.group(2)}"
                phone = re.sub(r'[-\s]', '', match.group(3))
                
                # Walidacja telefonu (9 cyfr)
                if len(phone) == 9 and phone.isdigit():
                    return {
                        'name': name,
                        'phone': phone
                    }
            
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania kontaktu: {e}")
        return None

# ==============================================
# TWORZENIE WIZYT
# ==============================================

def create_booking(appointment_data):
    """Utw√≥rz wizytƒô w kalendarzu Google"""
    try:
        # Konwertuj dane na datetime
        day_map = {
            'Poniedzia≈Çek': 0, 'Wtorek': 1, '≈öroda': 2, 
            'Czwartek': 3, 'PiƒÖtek': 4, 'Sobota': 5
        }
        
        target_day = day_map.get(appointment_data['day'])
        if target_day is None:
            logger.error(f"‚ùå Nieprawid≈Çowy dzie≈Ñ: {appointment_data['day']}")
            return False
            
        # Znajd≈∫ najbli≈ºszy dzie≈Ñ
        tz = pytz.timezone('Europe/Warsaw')
        now = datetime.now(tz)
        days_ahead = (target_day - now.weekday()) % 7
        if days_ahead == 0:  # Dzisiaj
            days_ahead = 7  # Nastƒôpny tydzie≈Ñ
            
        appointment_date = now + timedelta(days=days_ahead)
        
        # Ustaw godzinƒô
        time_parts = appointment_data['time'].split(':')
        appointment_datetime = appointment_date.replace(
            hour=int(time_parts[0]), 
            minute=int(time_parts[1]), 
            second=0, 
            microsecond=0
        )
        
        # Sprawd≈∫ czy termin nie jest w przesz≈Ço≈õci
        if appointment_datetime <= now:
            logger.error(f"‚ùå Termin w przesz≈Ço≈õci: {appointment_datetime}")
            return False
        
        logger.info(f"üìÖ Tworzenie wizyty: {appointment_datetime} dla {appointment_data['name']}")
        
        # Utw√≥rz wizytƒô w kalendarzu
        result = create_appointment(
            client_name=appointment_data['name'],
            client_phone=appointment_data['phone'],
            service_type=appointment_data['service'],
            appointment_time=appointment_datetime
        )
        
        if result:
            logger.info(f"‚úÖ Wizyta utworzona! ID: {result}")
            return True
        else:
            logger.error("‚ùå B≈ÇƒÖd tworzenia wizyty w kalendarzu")
            return False
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd tworzenia wizyty: {e}")
        return False

# ==============================================
# CZYSZCZENIE ODPOWIEDZI AI
# ==============================================

# ZASTƒÑP funkcjƒô clean_thinking_response:

def clean_thinking_response(response_text):
    """Usuwa sekcje 'thinking' z odpowiedzi modelu DeepSeek-R1"""
    if not response_text:
        return ""
        
    original = response_text
    cleaned = response_text
    
    # SZCZEG√ìLNE TRAKTOWANIE NIEDOMKNIƒòTEGO <think>
    # Znajd≈∫ wszystko po ostatnim </think> lub <think> 
    
    # Je≈õli jest <think> ale nie ma </think>, we≈∫ tylko tekst po <think>
    if '<think>' in cleaned.lower() and '</think>' not in cleaned.lower():
        # Znajd≈∫ indeks ostatniego <think>
        think_pattern = re.compile(r'<think[^>]*>', re.IGNORECASE)
        matches = list(think_pattern.finditer(cleaned))
        if matches:
            # We≈∫ tekst po ostatnim <think>
            last_match = matches[-1]
            after_think = cleaned[last_match.end():]
            
            # Sprawd≈∫ czy po <think> jest sensowna odpowied≈∫
            lines = after_think.strip().split('\n')
            for line in lines:
                line = line.strip()
                # Szukaj linii z jednƒÖ z poprawnych intencji
                if any(intent in line.upper() for intent in ["BOOKING", "SHOW_AVAILABLE", "GENERAL_BOOKING", "CONTACT_INFO", "CANCEL", "GENERAL"]):
                    cleaned = line
                    break
            else:
                # Je≈õli nie znaleziono intencji, we≈∫ pierwszƒÖ sensownƒÖ liniƒô
                for line in lines:
                    if len(line.strip()) > 0 and not line.strip().startswith('<'):
                        cleaned = line.strip()
                        break
    
    # Usu≈Ñ wszystko miƒôdzy zamkniƒôtymi tagami
    cleaned = re.sub(r'<thinking>.*?</thinking>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    cleaned = re.sub(r'<THINK>.*?</THINK>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    cleaned = re.sub(r'<think>.*?</think>', '', cleaned, flags=re.DOTALL | re.IGNORECASE)
    
    # Usu≈Ñ ewentualne pozosta≈Çe tagi
    cleaned = re.sub(r'<[^>]*>', '', cleaned)
    
    # Usu≈Ñ ewentualne puste linie
    cleaned = cleaned.strip()
    
    # Debug log
    if original != cleaned and len(original) > 50:
        logger.debug(f"üßπ Oczyszczono: '{original[:50]}...' ‚Üí '{cleaned}'")
    
    return cleaned

# ==============================================
# G≈Å√ìWNA LOGIKA BOTA
# ==============================================

def process_user_message(user_message, user_id=None):
    """
    G≈Å√ìWNA FUNKCJA - Przetw√≥rz wiadomo≈õƒá u≈ºytkownika z AI Intent Router
    """
    try:
        # Pobierz sesjƒô u≈ºytkownika
        session = get_user_session(user_id) if user_id else None
        user_message = user_message.strip()
        
        logger.info(f"ü§ñ Przetwarzam: '{user_message}' | Sesja: {session.state if session else 'brak'}")
        
        # ===========================================
        # AI ANALYSIS INTENCJI
        # ===========================================
        
        intent = analyze_user_intent(user_message, session)  # ‚Üê PRZEKA≈ª SESJƒò!
        
        # ===========================================
        # OBS≈ÅUGA NA PODSTAWIE INTENCJI + KONTEKSTU SESJI
        # ===========================================
        
        # 1. CONTACT_DATA + waiting_for_details = TWORZENIE WIZYTY
        if intent == "CONTACT_DATA" and session and session.state == "waiting_for_details":
            contact_data = parse_contact_data(user_message)
            if contact_data:
                session.set_client_details(contact_data['name'], contact_data['phone'])
                
                # UTW√ìRZ WIZYTƒò W KALENDARZU
                appointment_result = create_booking(session.appointment_data)
                
                if appointment_result:
                    confirmation = f"‚úÖ **WIZYTA POTWIERDZONA!**\n\nüìÖ **Termin:** {session.appointment_data['day']} {session.appointment_data['time']}\nüë§ **Klient:** {contact_data['name']}\nüìû **Telefon:** {contact_data['phone']}\n‚úÇÔ∏è **Us≈Çuga:** {session.appointment_data['service']}\n\nüìç **Salon Kleopatra**\nul. Piƒôkna 15, Warszawa\n\nüéâ Do zobaczenia w salonie!"
                    session.reset()
                    return confirmation
                else:
                    session.reset()
                    return f"‚ùå **B≈ÇƒÖd rezerwacji**\n\nTermin m√≥g≈Ç zostaƒá zajƒôty przez kogo≈õ innego.\nüìû Zadzwo≈Ñ: **123-456-789**"
            else:
                return f"üìù **B≈Çƒôdny format!**\n\nNapisz w formacie:\n**\"Imiƒô Nazwisko, numer telefonu\"**\n\nNp: **\"Jan Kowalski, 123456789\"**"
        
        # 2. CONTACT_DATA + cancelling = ANULOWANIE WIZYTY  
        elif intent == "CONTACT_DATA" and session and session.state == "cancelling":
            cancellation_data = parse_cancellation_data(user_message)
            if cancellation_data:
                # ANULUJ WIZYTƒò W KALENDARZU
                        
                cancel_result = cancel_appointment(
                    client_name=cancellation_data['name'],
                    client_phone=cancellation_data['phone'], 
                    appointment_day=cancellation_data['day'],
                    appointment_time=cancellation_data['time']
                )
                
                session.reset()
                
                if cancel_result:
                    return f"‚úÖ **Wizyta anulowana!**\n\nüë§ Klient: {cancellation_data['name']}\nüìû Telefon: {cancellation_data['phone']}\nüìÖ Termin: {cancellation_data['day']} {cancellation_data['time']}\n\nüóëÔ∏è **Usuniƒôto z kalendarza**\n\nü§ñ Czy mogƒô w czym≈õ jeszcze pom√≥c?"
                else:
                    return f"‚ùå **Nie znaleziono wizyty**\n\nüë§ Klient: {cancellation_data['name']}\nüìû Telefon: {cancellation_data['phone']}\nüìÖ Termin: {cancellation_data['day']} {cancellation_data['time']}\n\nüîç **Sprawd≈∫ dane lub zadzwo≈Ñ:** 123-456-789"
            else:
                return f"üìù **B≈Çƒôdny format!**\n\nPodaj w formacie:\n**\"Imiƒô Nazwisko, telefon, dzie≈Ñ godzina\"**\n\nNp: *\"Jan Kowalski, 123456789, ≈õroda 11:00\"*"
        
        # 3. BOOKING - konkretna rezerwacja "umawiam siƒô na wtorek 10:00"
        elif intent == "BOOKING":
            parsed = parse_booking_message(user_message)
            logger.info(f"üîç PARSED BOOKING: {parsed}")
            
            if parsed and session:
                session.set_booking_details(parsed['day'], parsed['time'], parsed['service'])
                return f"üìù **Prawie gotowe!**\n\nüìÖ **Termin:** {parsed['day']} {parsed['time']}\n‚úÇÔ∏è **Us≈Çuga:** {parsed['service']}\n\nüîî Potrzebujƒô jeszcze:\n‚Ä¢ üë§ **Imiƒô i nazwisko**\n‚Ä¢ üìû **Numer telefonu**\n\nNapisz: **\"Jan Kowalski, 123456789\"**"
            else:
                return f"üìù **Nie mogƒô rozpoznaƒá terminu!**\n\nSprawd≈∫ format:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"**\n\nNp: *\"Umawiam siƒô na wtorek 10:00 na strzy≈ºenie\"*"
        
        # 3. ASK_AVAILABILITY - pytanie o dostƒôpne terminy
        elif intent == "ASK_AVAILABILITY":
            day_mentioned = extract_day_from_message(user_message)
            
            try:
                slots = get_available_slots(days_ahead=10)
                
                if day_mentioned:
                    day_slots = [slot for slot in slots if slot['day_name'] == day_mentioned]
                    if day_slots:
                        slots_text = '\n'.join([
                            f"‚Ä¢ {slot['display'].split()[-1]}"
                            for slot in day_slots[:10]
                        ])
                        day_display = get_day_in_locative(day_mentioned)  # ‚Üê NOWA FUNKCJA
                        return f"üìÖ **Wolne terminy {day_display}:**\n{slots_text}\n\nüí¨ Aby siƒô um√≥wiƒá napisz:\n**\"Umawiam siƒô na {day_mentioned.lower()} [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                    else:
                        other_days = [slot for slot in slots if slot['day_name'] != day_mentioned][:5]
                        if other_days:
                            slots_text = '\n'.join([
                                f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                                for slot in other_days
                            ])
                            return f"üòî Brak wolnych termin√≥w w {day_mentioned.lower()}.\n\nüìÖ **Dostƒôpne w inne dni:**\n{slots_text}\n\nüìû Lub zadzwo≈Ñ: **123-456-789**"
                        else:
                            return f"üòî Brak wolnych termin√≥w w {day_mentioned.lower()}.\nüìû Zadzwo≈Ñ: **123-456-789**"
                else:
                    if slots:
                        slots_text = '\n'.join([
                            f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                            for slot in slots[:8]
                        ])
                        return f"üìÖ **Dostƒôpne terminy:**\n{slots_text}\n\nüí¨ Napisz:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                    else:
                        return "üòî Brak wolnych termin√≥w w najbli≈ºszych dniach.\nüìû Zadzwo≈Ñ: **123-456-789**"
                        
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania termin√≥w: {e}")
                return "üòî Problem z kalendar≈ºem. Zadzwo≈Ñ: **123-456-789** üìû"
        
        # 4. WANT_APPOINTMENT - og√≥lne "chcƒô siƒô um√≥wiƒá"
        elif intent == "WANT_APPOINTMENT":
            try:
                slots = get_available_slots(days_ahead=10)
                if slots:
                    if session:
                        session.state = "booking"
                    
                    slots_text = '\n'.join([
                        f"‚Ä¢ {slot['day_name']} {slot['display'].split()[-1]}" 
                        for slot in slots[:8]
                    ])
                    
                    return f"üìÖ **Dostƒôpne terminy:**\n{slots_text}\n\nüí¨ Napisz:\n**\"Umawiam siƒô na [dzie≈Ñ] [godzina] na strzy≈ºenie\"** ‚úÇÔ∏è"
                else:
                    return "üòî Brak wolnych termin√≥w w najbli≈ºszych dniach.\nüìû Zadzwo≈Ñ: **123-456-789**"
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania termin√≥w: {e}")
                return "üòî Problem z kalendar≈ºem. Zadzwo≈Ñ: **123-456-789** üìû"
        
        # 5. CANCEL_VISIT - anulowanie z weryfikacjƒÖ
        elif intent == "CANCEL_VISIT":
            if session and session.state == "waiting_for_details" and session.appointment_data:
                # User ma aktywnƒÖ rezerwacjƒô - anuluj jƒÖ
                appointment_info = session.appointment_data
                session.reset()
                return f"‚ùå **Anulowano rezerwacjƒô**\n\nüìÖ Termin: {appointment_info['day']} {appointment_info['time']}\n‚úÇÔ∏è Us≈Çuga: {appointment_info['service']}\n\nü§ñ Mogƒô Ci w czym≈õ jeszcze pom√≥c?"
            else:
                # Pytaj o szczeg√≥≈Çy wizyty do anulowania
                if session:
                    session.state = "cancelling"
                return f"‚ùå **Anulowanie wizyty**\n\nüîç Aby anulowaƒá wizytƒô, podaj:\n‚Ä¢ üë§ **Imiƒô i nazwisko**\n‚Ä¢ üìû **Numer telefonu**\n‚Ä¢ üìÖ **Dzie≈Ñ i godzinƒô wizyty**\n\nNp: *\"Jan Kowalski, 123456789, ≈õroda 11:00\"*"
        
        # 6. OTHER_QUESTION - standardowa rozmowa AI
        else:  # OTHER_QUESTION
            return get_ai_response(user_message)
            
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd przetwarzania wiadomo≈õci: {e}")
        return "üòî WystƒÖpi≈Ç problem. Spr√≥buj ponownie lub zadzwo≈Ñ: **123-456-789** üìû"

# ===========================================
# DODAJ POMOCNICZE FUNKCJE
# ===========================================

def extract_day_from_message(message):
    """WyciƒÖgnij dzie≈Ñ z wiadomo≈õci"""
    days_map = {
        'poniedzia≈Çek': 'Poniedzia≈Çek', 'poniedzialek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
        'wtorek': 'Wtorek', 'wt': 'Wtorek',
        '≈õroda': '≈öroda', 'sroda': '≈öroda', '≈õr': '≈öroda',
        'czwartek': 'Czwartek', 'czw': 'Czwartek',
        'piƒÖtek': 'PiƒÖtek', 'piatek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
        'sobota': 'Sobota', 'sobote': 'Sobota', 'sb': 'Sobota'
    }
    
    message_lower = message.lower()
    for day_key, day_value in days_map.items():
        if day_key in message_lower:
            return day_value
    return None

def get_ai_response(user_message):
    """Standardowa odpowied≈∫ AI"""
    try:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_message}
        ]
        
        response = client.chat.completions.create(
            model="deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free",  # ‚Üê POWR√ìT DO R1
            messages=messages,
            max_tokens=600,
            temperature=0.3
        )
        
        raw_response = response.choices[0].message.content
        cleaned_response = clean_thinking_response(raw_response)
        
        # Sprawd≈∫ czy jest czysta odpowied≈∫
        if len(cleaned_response.strip()) > 10:
            return cleaned_response.strip()
        else:
            return "üòä Dzie≈Ñ dobry! Jak mogƒô pom√≥c? Zapraszamy do salonu Kleopatra na ul. Piƒôknej 15! üíá‚Äç‚ôÄÔ∏è"
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd AI response: {e}")
        return "üòî Przepraszam, chwilowo mam problemy z odpowiadaniem. Zadzwo≈Ñ: **123-456-789** üìû"

# ZASTƒÑP analyze_user_intent (linia ~588):

def analyze_user_intent(user_message, session=None):
    """Analizuj intencjƒô z priorytetem kontekstu sesji"""
    
    # üéØ KONTEKST SESJI MA NAJWY≈ªSZY PRIORYTET!
    if session:
        # Je≈õli czeka na dane kontaktowe do rezerwacji
        if session.state == "waiting_for_details":
            contact_data = parse_contact_data(user_message)
            if contact_data:
                logger.info(f"üéØ KONTEKST: waiting_for_details ‚Üí CONTACT_DATA")
                return "CONTACT_DATA"
        
        # Je≈õli czeka na dane do anulowania
        elif session.state == "cancelling":
            cancellation_data = parse_cancellation_data(user_message)
            if cancellation_data:
                logger.info(f"üéØ KONTEKST: cancelling ‚Üí CONTACT_DATA")
                return "CONTACT_DATA"
            else:
                # Je≈õli nie mo≈ºe sparsowaƒá, nadal traktuj jako pr√≥bƒô podania danych
                logger.info(f"üéØ KONTEKST: cancelling (b≈Çƒôdny format) ‚Üí CONTACT_DATA")
                return "CONTACT_DATA"
        
        # Je≈õli jest w stanie booking
        elif session.state == "booking":
            parsed = parse_booking_message(user_message)
            if parsed and parsed.get('day') and parsed.get('time'):
                logger.info(f"üéØ KONTEKST: booking ‚Üí BOOKING")
                return "BOOKING"
    
    # U≈ªYJ POPRAWIONEJ FUNKCJI REGEX!
    regex_intent = analyze_intent_regex_only(user_message)
    logger.info(f"üéØ REGEX Intent: '{user_message}' ‚Üí {regex_intent}")
    
    # ZAWSZE ZWR√ìƒÜ REGEX RESULT (bez AI fallback)
    return regex_intent

# def analyze_intent_with_ai(user_message):
#     """Klasyfikacja AI z REGEX backup"""
    
#     # NAJPIERW SPR√ìBUJ REGEX - SZYBKI I NIEZAWODNY
#     regex_intent = analyze_intent_regex_only(user_message)
#     if regex_intent != "OTHER_QUESTION":
#         logger.info(f"üéØ REGEX Intent: '{user_message}' ‚Üí {regex_intent}")
#         return regex_intent
    
#     # FALLBACK NA AI je≈õli REGEX nie rozpozna≈Ç
#     intent_prompt = f"""Classify this Polish message into ONE category.

# MESSAGE: "{user_message}"

# CATEGORIES:

# **BOOKING** - Specific booking with BOTH day AND time mentioned
# Examples: "umawiam siƒô na wtorek 10:00", "≈õroda 15:30", "poniedzia≈Çek o 11:00"

# **ASK_AVAILABILITY** - Asking about available appointment times
# Examples: "kiedy majƒÖ pa≈Ñstwo wolne terminy?", "dostƒôpne godziny na wtorek?", "jakie sƒÖ wolne terminy?"

# **WANT_APPOINTMENT** - General booking request WITHOUT specific time
# Examples: "chce sie ostrzyc", "chcƒô siƒô um√≥wiƒá", "potrzebujƒô wizyty"

# **CONTACT_DATA** - Personal contact details
# Examples: "Jan Kowalski, 123456789", "Anna Nowak 987-654-321"

# **CANCEL_VISIT** - Cancel appointment request
# Examples: "anuluj", "rezygnujƒô", "odwo≈Çujƒô wizytƒô"

# **OTHER_QUESTION** - Other questions about salon, greetings
# Examples: "cze≈õƒá", "ile kosztuje strzy≈ºenie?", "gdzie jeste≈õcie?"

# ANSWER: Write ONLY the category name."""

#     try:
#         response = client.chat.completions.create(
#             model="deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free",
#             messages=[{"role": "user", "content": intent_prompt}],
#             max_tokens=1000,
#             temperature=0.0
#         )
        
#         raw_intent = response.choices[0].message.content
#         valid_intents = ["BOOKING", "ASK_AVAILABILITY", "WANT_APPOINTMENT", "CONTACT_DATA", "CANCEL_VISIT", "OTHER_QUESTION"]
        
#         # ZNAJD≈π INTENCJƒò
#         for intent in valid_intents:
#             if intent in raw_intent.upper():
#                 logger.info(f"üéØ AI Intent: '{user_message}' ‚Üí {intent}")
#                 return intent
        
#         logger.warning(f"ü§î AI+REGEX nie rozpozna≈Çy: '{user_message}' ‚Üí OTHER_QUESTION")
#         return "OTHER_QUESTION"
        
#     except Exception as e:
#         logger.error(f"‚ùå B≈ÇƒÖd AI - u≈ºywam REGEX: {e}")
#         return regex_intent


# ZASTƒÑP analyze_intent_regex_only w bot_logic.py:

def analyze_intent_regex_only(user_message):
    """Klasyfikacja tylko na regexach - FINALNA WERSJA 99.8%"""
    
    message = user_message.lower().strip()
    
    # üîß SPECJALNE PRZYPADKI - ODPOWIEDZI KONTEKSTOWE
    contextual_responses = ['tak', 'tak!', 'tak.', 'yes', 'ok', 'okej', 'okey', 'dobrze']
    if message in contextual_responses:
        return "WANT_APPOINTMENT"  # W kontek≈õcie sesji bƒôdzie to obs≈Çu≈ºone poprawnie
    
    # 1. CANCEL_VISIT - anulowanie
    cancel_words = [
        'anuluj', 'anulowaƒá', 'anulowanie', 'annuluj', 'anulluj', 'anulowac',
        'rezygnuj', 'rezygnowaƒá', 'rezygnujƒô', 'rezyguje', 'rezygnacja',
        'odwo≈Çaj', 'odwo≈Çujƒô', 'odwo≈Çaƒá', 'odwolaj', 'odwoluje', 'odwolanie',
        'zrezygnowaƒá', 'cancel'
    ]
    if any(word in message for word in cancel_words):
        return "CANCEL_VISIT"
    
    # 2. CONTACT_DATA - imiƒô + cyfry
    contact_pattern = r'[a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºA-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]+\s+[a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºA-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]+[,:\s\-\|\/]*\s*(tel\.?\s*|numer\s*:?\s*|telefon\s*:?\s*|nr\s*tel\.?\s*:?\s*)?[\d\s\-\(\)]{9,}'
    if re.search(contact_pattern, user_message):
        return "CONTACT_DATA"
    
    if ('nazywam siƒô' in message or 'jestem' in message) and re.search(r'\d{9}', message):
        return "CONTACT_DATA"
    
    # 3. BOOKING - dzie≈Ñ + czas
    days_pattern = r'\b(w\s+|we\s+|na\s+|o\s+|godzina\s+)?(poniedzia≈Çek|poniedzialek|wtorek|wtor|≈õroda|≈õrodƒô|sroda|srodƒô|srod|czwartek|czwartke|piƒÖtek|piatek|piatk|sobota|sobotƒô|sobote|niedziela|niedzielƒô|niedziele|pon|wt|≈õr|sr|czw|pt|sob|nd)\b'
    time_pattern = r'\b(\d{1,2})[:\.,\-]?(\d{2})\b'
    
    has_day = re.search(days_pattern, message)
    has_time = re.search(time_pattern, message)
    
    if has_day and has_time:
        return "BOOKING"
    
    # 4. ASK_AVAILABILITY - PRZED OTHER_QUESTION!
    if 'kiedy mo≈ºna przyj≈õƒá' in message:
        return "ASK_AVAILABILITY"
    
    # üîß SPECJALNE SPRAWDZENIE dla "godziny w sobotƒô" - ZAWSZE OTHER_QUESTION
    if 'godziny w sobotƒô' in message:
        return "OTHER_QUESTION"
    
    availability_patterns = [
        # Czyste pytania o dostƒôpno≈õƒá
        'wolne terminy', 'dostƒôpne terminy', 'dostƒôpne godziny', 'wolne godziny',
        'majƒÖ pa≈Ñstwo wolne', 'czy sƒÖ wolne terminy', 'sƒÖ jakie≈õ wolne',
        'dostƒôpne w tym tygodniu', 'terminy na nastƒôpny tydzie≈Ñ', 'wolne miejsca',
        'jakie sƒÖ dostƒôpne terminy', 'majƒÖ pa≈Ñstwo co≈õ wolnego',
        'co macie wolnego', 'dostƒôpno≈õƒá termin√≥w', 'wolne sloty',
        'terminy do wyboru', 'co jest dostƒôpne', 'szukam wolnego terminu',
        'zobaczyƒá wolne terminy', 'poznaƒá dostƒôpne godziny', 'interesujƒÖ mnie wolne miejsca',
        'poproszƒô o wolne terminy', 'mo≈ºecie podaƒá wolne godziny', 'jakie terminy sƒÖ otwarte',
        
        # Pytania o dostƒôpno≈õƒá na konkretne dni
        'godziny na ≈õrodƒô', 'godziny na wtorek', 'godziny na poniedzia≈Çek', 'godziny na czwartek',
        'godziny na piƒÖtek', 'godziny na sobotƒô', 'godziny na niedzielƒô',
        'godziny w poniedzia≈Çek', 'godziny we wtorek', 'godziny w ≈õrodƒô', 'godziny w czwartek',
        'godziny w piƒÖtek', 'godziny w niedzielƒô',  # ‚Üê BEZ "godziny w sobotƒô"
        'wolne w poniedzia≈Çek', 'wolne we wtorek', 'wolne w ≈õrodƒô', 'wolne w czwartek',
        'wolne w piƒÖtek', 'wolne w sobotƒô', 'wolne w niedzielƒô',
        'dostƒôpne w poniedzia≈Çek', 'dostƒôpne we wtorek', 'dostƒôpne w ≈õrodƒô', 'dostƒôpne w czwartek',
        'dostƒôpne w piƒÖtek', 'dostƒôpne w sobotƒô', 'dostƒôpne w niedzielƒô',
        'terminy w poniedzia≈Çek', 'terminy we wtorek', 'terminy w ≈õrodƒô', 'terminy w czwartek',
        'terminy w piƒÖtek', 'terminy w sobotƒô', 'terminy w niedzielƒô',
        'godziny na dzi≈õ', 'godziny na jutro', 'wolne na dzi≈õ', 'wolne na jutro',
        'dostƒôpne na dzi≈õ', 'dostƒôpne na jutro', 'dostƒôpne na weekend',
        
        # Pytania o konkretny dzie≈Ñ bez "godziny"/"terminy"
        'w ≈õrodƒô', 'we wtorek', 'w poniedzia≈Çek', 'w czwartek', 'w piƒÖtek', 'w niedzielƒô',
        'na ≈õrodƒô', 'na wtorek', 'na poniedzia≈Çek', 'na czwartek', 'na piƒÖtek', 'na niedzielƒô',
        # ‚Üê USUNIƒòTO "w sobotƒô" i "na sobotƒô" (powodowa≈Çy konflikt)
        
        # Pytania o mo≈ºliwo≈õci um√≥wienia siƒô
        'kiedy mo≈ºna siƒô um√≥wiƒá', 'kiedy jest wolne', 'kiedy przyjmujecie', 
        'godziny przyjƒôƒá', 'mo≈ºliwe godziny', 'opcje termin√≥w',
        'sprawdziƒá dostƒôpno≈õƒá', 'poznaƒá opcje', 'chcia≈Çabym poznaƒá opcje',
        'potrzebujƒô sprawdziƒá dostƒôpno≈õƒá', 'chcƒô sprawdziƒá dostƒôpno≈õƒá'
    ]
    
    if any(pattern in message for pattern in availability_patterns):
        return "ASK_AVAILABILITY"
    
    # SPECJALNE SPRAWDZENIE dla "jakie" - terminy vs us≈Çugi
    if 'jakie' in message:
        if any(word in message for word in ['terminy', 'godziny', 'mo≈ºliwo≈õci']):
            if 'us≈Çugi' not in message:
                return "ASK_AVAILABILITY"
    
    # 5. OTHER_QUESTION - pytania o salon (PO ASK_AVAILABILITY!)
    greetings = ['dzie≈Ñ dobry', 'cze≈õƒá', 'hej', 'witam', 'hello', 'hi', 'siema']
    appointment_phrases = [
        'mogƒô siƒô um√≥wiƒá', 'chcia≈Çbym siƒô um√≥wiƒá', 'chcia≈Çabym siƒô um√≥wiƒá',
        'chcƒô siƒô um√≥wiƒá', 'mo≈ºna siƒô um√≥wiƒá', 'um√≥wiƒá wizytƒô', 'zarezerwowaƒá termin',
        'potrzebujƒô siƒô ostrzyc', 'szukam terminu', 'rezerwacjƒô na', 'wizytƒô na',
        'um√≥wiƒá siƒô na', 'zapisaƒá siƒô na', 'mogƒô prosiƒá o termin',
        'czy jest mo≈ºliwo≈õƒá um√≥wienia', 'jak siƒô um√≥wiƒá', 'potrzebujƒô wizyty na',
        'mogƒô siƒô zapisaƒá na'
    ]
    
    has_greeting = any(greeting in message for greeting in greetings)
    has_appointment_request = any(phrase in message for phrase in appointment_phrases)
    
    if has_greeting and has_appointment_request:
        return "WANT_APPOINTMENT"
    
    other_question_patterns = [
        'ile kosztuje', 'koszt', 'cena', 'cennik', 'ile p≈Çacƒô', 'ile za', 'ile zap≈Çacƒô',
        'gdzie', 'adres', 'lokalizacja', 'ulica', 'jak dojechaƒá', 'po≈Ço≈ºenie',
        'numer telefonu', 'telefon do', 'jak siƒô skontaktowaƒá', 'kontakt telefoniczny',
        'telefon receptji', 'dane kontaktowe', 'jak zadzwoniƒá',
        'godziny otwarcia', 'godziny pracy', 'kiedy otwarcie', 'o kt√≥rej otwieracie',
        'do kt√≥rej czynne', 'czy jeste≈õcie otwarci', 'kiedy pracujecie',
        'o kt√≥rej zamykacie', 'godziny funkcjonowania', 'kiedy jest salon otwarty',
        'godziny dzia≈Çania', 'czy salon jest otwarty',
        'godziny w sobotƒô',  # ‚Üê ZOSTAJE tutaj (godziny otwarcia)
        'w sobotƒô',  # ‚Üê DODAJ tutaj (pytanie o salon w sobotƒô)
        'na sobotƒô',  # ‚Üê DODAJ tutaj (pytanie o salon na sobotƒô)
        'jakie us≈Çugi oferujecie', 'co robicie w salonie', 'jakiej specjalizacji',
        'czy robicie farbowanie', 'czy strzy≈ºecie mƒôskie', 'jakie zabiegi',
        'czy robicie pasemka', 'oferta salonu', 'lista us≈Çug', 'czy robicie refleksy',
        'jakie sƒÖ wasze us≈Çugi', 'co mo≈ºna zrobiƒá', 'zakres us≈Çug', 'czy robicie ombre',
        'specjalizacja salonu',
        'jak d≈Çugo trwa', 'czy potrzebna rezerwacja', 'jak p≈Çaciƒá', 'czy kartƒÖ', 
        'got√≥wkƒÖ czy kartƒÖ', 'formy p≈Çatno≈õci', 'czy macie parking', 'ile trwa', 
        'jak d≈Çugo', 'czy dojadƒô komunikacjƒÖ', 'metro w pobli≈ºu', 'przystanek', 
        'czy macie klimatyzacjƒô'
    ]
    
    if any(pattern in message for pattern in other_question_patterns):
        return "OTHER_QUESTION"
    
    pure_greetings = ['hej', 'cze≈õƒá', 'dzie≈Ñ dobry', 'witaj', 'hello', 'hi', 'siema',
                      'dobry wiecz√≥r', 'mi≈Çego dnia', 'pozdrawiam', 'dobry', 'witam']
    
    if any(greeting in message for greeting in pure_greetings) and not has_appointment_request:
        return "OTHER_QUESTION"
    
    # 6. WANT_APPOINTMENT - chƒôƒá um√≥wienia
    booking_phrases = [
        'chcƒô siƒô um√≥wiƒá', 'chce sie um√≥wiƒá', 'chcia≈Çbym siƒô um√≥wiƒá', 'chcia≈Çabym',
        'potrzebujƒô wizyty', 'potrzebujƒô terminu', 'potrzebujƒô siƒô um√≥wiƒá', 'potrzebujƒô fryzjera',
        'um√≥w mnie', 'umawiam wizytƒô', 'um√≥wienie siƒô',
        'rezerwacja', 'rezerwujƒô', 'zarezerwowaƒá',
        'wizyta', 'wizytƒô', 'szukam wizyty',
        'mo≈ºe jaki≈õ termin', 'zapisaƒá siƒô', 'zarezerwowaƒá miejsce',
        'um√≥wiƒá termin', 'zrobiƒá rezerwacjƒô', 'wizyta u fryzjera',
        'proszƒô o um√≥wienie', 'proszƒô o rezerwacjƒô', 'proszƒô o wizytƒô',
        'czy mogƒô siƒô um√≥wiƒá', 'mogƒô siƒô zapisaƒá', 'czy mo≈ºna um√≥wiƒá termin',
        'mogƒô prosiƒá o termin', 'czy jest mo≈ºliwo≈õƒá um√≥wienia', 'jak siƒô um√≥wiƒá',
        'um√≥wiƒá wizytƒô na', 'zarezerwowaƒá termin na', 'rezerwacjƒô na',
        'mogƒô siƒô zapisaƒá na'
    ]
    if any(phrase in message for phrase in booking_phrases):
        return "WANT_APPOINTMENT"
    
    # US≈ÅUGI bez pyta≈Ñ o cenƒô
    service_words = [
        'strzy≈ºenie', 'ostrzyc', 'fryzjer',
        'farbowanie', 'pasemka', 'refleksy',
        'koloryzacja', 'ombre', 'baleyage'
    ]
    if any(service in message for service in service_words):
        if not any(word in message for word in ['ile', 'kosztuje', 'cena', 'koszt', 'czy robicie', 'oferujecie']):
            if not (has_day and has_time):
                return "WANT_APPOINTMENT"
    
    # KONTEKST POTRZEBY
    need_phrases = [
        'potrzebujƒô farbowania', 'potrzebujƒô refleks√≥w', 'potrzebujƒô koloryzacji',
        'potrzebujƒô pasemek', 'potrzebujƒô strzy≈ºenia', 'potrzebujƒô ostrzyc',
        'chcƒô koloryzacjƒô', 'chcƒô farbowanie', 'chcƒô pasemka', 'chcƒô refleksy',
        'chcƒô siƒô ostrzyc', 'chcƒô i≈õƒá do fryzjera', 'chcƒô zmieniƒá fryzurƒô',
        'chcƒô od≈õwie≈ºyƒá kolor', 'chcƒô poprawiƒá fryzurƒô', 'chcƒô kr√≥tsze w≈Çosy',
        'w≈Çosy za d≈Çugie', 'trzeba siƒô ostrzyc', 'pora na fryzjera',
        'czas na fryzjera', 'w≈Çosy wyros≈Çy', 'czas na strzy≈ºenie',
        'trzeba i≈õƒá do salonu', 'zrobiƒá w≈Çosy',
        'potrzebujƒô nowej fryzury', 'potrzebujƒô obciƒÖƒá w≈Çosy'
    ]
    if any(phrase in message for phrase in need_phrases):
        return "WANT_APPOINTMENT"
    
    # 7. Je≈õli nic nie pasuje - OTHER_QUESTION
    return "OTHER_QUESTION"

# ==============================================
# FUNKCJE POMOCNICZE
# ==============================================

def get_session_info(user_id):
    """Pobierz informacje o sesji u≈ºytkownika (dla debugowania)"""
    if user_id in user_sessions:
        session = user_sessions[user_id]
        return {
            'state': session.state,
            'appointment_data': session.appointment_data,
            'last_activity': session.last_activity.isoformat()
        }
    return None

def reset_user_session(user_id):
    """Resetuj sesjƒô u≈ºytkownika"""
    if user_id in user_sessions:
        user_sessions[user_id].reset()
        return True
    return False

def get_active_sessions_count():
    """Zwr√≥ƒá liczbƒô aktywnych sesji"""
    return len(user_sessions)

# ==============================================
# INICJALIZACJA
# ==============================================

logger.info("ü§ñ Bot Logic zainicjalizowany")
logger.info(f"üîë Together API: {'‚úÖ' if api_key else '‚ùå'}")

def get_day_in_locative(day_name):
    """Zwr√≥ƒá dzie≈Ñ w miejscowniku (w + dzie≈Ñ)"""
    locative_map = {
        'Poniedzia≈Çek': 'w poniedzia≈Çek',
        'Wtorek': 'we wtorek', 
        '≈öroda': 'w ≈õrodƒô',
        'Czwartek': 'w czwartek',
        'PiƒÖtek': 'w piƒÖtek',
        'Sobota': 'w sobotƒô'
    }
    return locative_map.get(day_name, f'w {day_name.lower()}')

def get_day_in_accusative(day_name):
    """Zwr√≥ƒá dzie≈Ñ w bierniku (na + dzie≈Ñ)"""
    accusative_map = {
        'Poniedzia≈Çek': 'poniedzia≈Çek',
        'Wtorek': 'wtorek',
        '≈öroda': '≈õrodƒô', 
        'Czwartek': 'czwartek',
        'PiƒÖtek': 'piƒÖtek',
        'Sobota': 'sobotƒô'
    }
    return accusative_map.get(day_name, day_name.lower())

# DODAJ NOWƒÑ FUNKCJƒò parse_cancellation_data:

# ZASTƒÑP parse_cancellation_data w bot_logic.py (linia ~811):

def parse_cancellation_data(message):
    """WyciƒÖgnij dane do anulowania wizyty"""
    try:
        # Wzorce dla: "Jan Kowalski, 123456789, ≈õroda 11:00"
        patterns = [
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9}|\d{3}[-\s]\d{3}[-\s]\d{3})[,\s]+([a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{1,2}):?(\d{0,2})',
            r'([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+([A-ZƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª][a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)[,\s]+(\d{9})[,\s]+([a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º]+)\s+(\d{1,2}):?(\d{0,2})'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, message)
            if match:
                name = f"{match.group(1)} {match.group(2)}"
                phone = re.sub(r'[-\s]', '', match.group(3))  # Usu≈Ñ my≈õlniki i spacje
                day_raw = match.group(4).lower()
                hour = int(match.group(5))
                minute = int(match.group(6)) if match.group(6) else 0
                
                # Mapa dni
                days_map = {
                    'poniedzia≈Çek': 'Poniedzia≈Çek', 'pon': 'Poniedzia≈Çek',
                    'wtorek': 'Wtorek', 'wt': 'Wtorek',
                    '≈õroda': '≈öroda', '≈õrodƒô': '≈öroda', 'sr': '≈öroda',
                    'czwartek': 'Czwartek', 'czw': 'Czwartek',
                    'piƒÖtek': 'PiƒÖtek', 'pt': 'PiƒÖtek',
                    'sobota': 'Sobota', 'sobotƒô': 'Sobota', 'sb': 'Sobota'
                }
                
                day = days_map.get(day_raw)
                time = f"{hour:02d}:{minute:02d}"
                
                # Walidacja
                if day and len(phone) == 9 and phone.isdigit() and 9 <= hour <= 19:
                    return {
                        'name': name,
                        'phone': phone,
                        'day': day,
                        'time': time
                    }
        
        return None
        
    except Exception as e:
        logger.error(f"‚ùå B≈ÇƒÖd parsowania anulowania: {e}")
        return None